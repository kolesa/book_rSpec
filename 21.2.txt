21.2  Navigating to Pages

Just as a user can’t click any links or submit any forms until he has typed a URL into his browser’s address bar and requested a web page, Webrat  can’t  manipulate  a  page  until  you’ve  given  it  a  place  to  start. The visit( ) method lets you open a page of your application.

Inside  each  scenario,  visit( )  must  be  called  before  any  other  Webrat methods. Usually you’ll call it with a routing helper, like we did in our When step definition from the previous section:

When /^I create a movie Caddyshack in the Comedy genre$/ do visit 
	movies_path
	# ... 
end

Behind the scenes, Webrat leverages Rails’ integration testing functionality to simulate GET requests and layers browser-like behavior on top. Like other Webrat methods that issue requests, it looks at the response code returned to figure out what to do next:

Successful (200–299) or Bad Request (400–499)  Webrat stores the response  so  that  subsequent  methods  can  fill  out  forms,  click links, or inspect its content.

Redirection (300–399)  If the redirect is to a URL within the domain of the  application,  Webrat  issues  a  new request  for  the  destination specified by the redirect, preserving HTTP headers and including a proper Location header. If the redirect is external, Webrat saves it as the response for later inspection but won’t follow it.

Server Error (500–599)  Webrat  raises  a  Webrat::PageLoadError.  If  you want to specify that making a request produces an error, you can use RSpec’s raise_error( ) to catch it.

Clicking Links

Once you’ve opened a page of your application using visit( ), you’ll often want to navigate to other pages. Rather than using visit( ) to load each URL  in  succession,  it’s  convenient  to  simulate  clicking  links  to  jump from page to page.

click_link( )  lets  you  identify  a  link  by  its  text  and  follows  it  by  making a request for the URL  it points to. To navigate to the URL  in the href, wherever that may be, of a Comedy link, we wrote this:

Then /^Caddyshack should be in the Comedy genre$/ do
	# ...
	click_link "Comedy"
	# ...
end



click_link( ) can lead to a more natural flow in your step definitions and has  the  advantage  that  your  step  definitions  are  less  bound  to  your routing scheme. On the other hand, each page load takes a little bit of time,  so  to  keep  your  scenarios  running  quickly,  you’ll  want  to  avoid navigating through many pages of the site that aren’t directly related to what you’re testing. Instead, you could pick an entry point for visit( ) closer to the area of the application you’re concerned with.

In  addition  to  clicking  links  based  on  the  text  between  the  <a>  tags, Webrat can locate links by their id and title values. For example, if we have the following HTML:

<a href="/" title="Example.com Home" id="home_link">
	Back to homepage
</a>

then the following step definitions would all be equivalent:

When /^I click to go back to the homepage$/ do
	# Clicking the link by its title 
	click_link "Example.com Home"
end

When /^I click to go back to the homepage$/ do
	# Clicking the link by its id 
	click_link "home_link"
end

When /^I click to go back to the homepage$/ do
	# Clicking the link by its text 
	click_link "Back to homepage"
end

click_link( ) has rudimentary support for handling JavaScript links generated by Rails’ link_to( ) for non-GET HTTP requests. Since it can’t actually run any JavaScript, it relies on matching the onclick  value with regu- lar expressions. This functionality, though limited, can be useful when dealing with  RESTful Rails applications that aren’t implemented with unobtrusive JavaScript techniques.

Let’s say the box-office application requires that a moderator approves movie listings before they are visible on the site. Here’s how you might express that with Webrat:

When /^I approve the listing$/ do
	click_link "Approve"
end

 web_steps .rb  

You might be looking  at the step definitions used throughout this chapter and wondering whether you’ll be forced to write step definitions for every When and Then step in each of your app’s scenarios. After all, maintaining separate step definitions for both When I click the Save button and When I click the Delete button (and more) would get tedious pretty quickly.

Fortunately, Cucumber has just the feature to help us out of this: parameterized  step  definitions.  Instead  of  maintaining  a  step definition for each button, we can write one that’s reusable by wrapping the Webrat API:

When /^I click the "(.+)" button$/ do |button_text|
	click_button button_text
end

In fact, Cucumber ships with a bunch of these sort of step  definitions  in  a  web_steps.rb  file.  It  was  added  to  your project’s step_definitions directory when you ran the Cucumber generator.

Be sure to take a look at what’s in there. It can save you quite a bit of time as you’re implementing new scenarios.

And here’s the likely implementation:

<%= link_to "Approve", approve_movie_path(movie), :method => :put %>

When  clicked,  the  link  would  normally  generate  a  PUT  request  to  the approve_movie_path.  You  can  disable  this  functionality  by  passing  the 
:javascript => false option to click_link( ):

When /^I approve the listing$/ do
	click_link "Approve", :javascript => false 
end

Instead of sending a PUT request, this tells Webrat to issue a GET request as if the JavaScript were not present. This can be useful when you want to specify the app works correctly for users without JavaScript enabled.

Now that we’re comfortable navigating to pages within our application, we can take a look at how to use Webrat to submit forms.
 